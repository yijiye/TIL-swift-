# Concurrency Programming Guide (동시성 프로그래밍)

## Introduction

- 동시성은 **여러가지 일들이 동시에 일어난다는 개념**이다.
- **동시성 프로그래밍의 필요성**: 멀티코어 CPU의 보급과 각 프로세서 내의 코어수가 증가함에 따라 개발자들이 그것들을 활용하는 방법이 필요해졌다.
- **현재 OS X, iOS와 같은 운영 체제  foreground에 거의 몰아져있음**: 여러 프로그램을 병렬적으로 사용할 수는 있으나 거의 백그라운드에서 실행되고 연속적인 프로세서 시간이 거의 필요하지 않다. 
- **낭비되지 않도록 활용하는 것, 동시성 프로그래밍** : 애플리케이션이 많은 작업을 하지만 사용 가능한 일부의 코어만 사용하고 추가 처리 리소스는 낭비되는 문제가 있다. 
- **스레드를 활용한 동시성의 한계** : 수동으로 관리해야하는 저수준 도구, 현재 시스템 부하와 기본 하드웨어에 따라 스레드 수가 변경될 수 있어 올바른 솔루션을 구현하는 것이 매우 어렵다. 또한 성능 향상을 보장하지 않고 소프트웨어 설계에 복잡성과 위험을 추가한다.
    - **스레드란**, 컴퓨터 프로그램에서 실행되는 흐름의 단위
    - 각각의 스레드는 프로세스 내에서 별도의 코드 실행 흐름을 가지며 동시에 여러 작업을 수행할 수 있다.

## Terminology

- 스레드: 코드에 대한 별도의 실행 경로. OS X의 스레드 기본 구현은 POSIX 스레드 API를 기반으로 한다.
- 프로세스: 여러 스레드를 포함할 수 있는 실행 중인 실행 파일을 지칭
- 테스크: 수행해야 할 작업의 추상적인 개념을 지칭하는 데 사용

# Concurrency and Application Design

- **컴퓨터 공학 초기**
   1) CPU의 클럭속도 (CPU가 처리할 수 있는 명령어의 수를 결정하는 시스템의 속도, CPU가 하나의 사이클을 완료하는데 걸리는 시간)에 따라 컴퓨터가 처리할 수 있는 작업량이 결정되었음.
   2) 기술이 발전하면서 여러가지 제약이 생겨 최대 클럭속도가 제한됨.
   3) 칩의 총 성능을 높이기 위한 방법을 모색
   4) 각 칩에 있는 프로세서 코어의 수를 늘림
- **코어의 수 증가함에 따라 활용하는 방법이 필요**
   - CPU의 속도를 증가시키지 않고도 단일 칩에서 더 많은 명령어를 실행할 수 있고, 칩의 크기나 열 특성을 변경하지 않아도 됨 (제약에 걸리지 않음!)
   - 그러나, 추가된 코어를 활용하는 방법이 필요
- **활용 방법 1 - 스레드 생성**
   - 스레드 코드가 임의의 코드 수에 대해 잘 확장되지 않는 문제 발생
   - 즉, 코어의 수만큼 스레드를 생성하고 프로그램을 잘 생성할지에 대한 이슈가 생김
   - 애플리케이션이 효율적으로 사용할 수 있는 코어의 수를 아는것도 중요하지만 응용프로그램이 자체적으로 계산하기 어려움
- **스레드의 한계를 보완해야 함**
   - 응용 프로그램이 가변적인 컴퓨터 코어 수를 활용할 수 있는 방법이 필요
   - 수행하는 작업 양도 동적으로 조정하여 시스템 상황 변화에 대응할 수 있어야함
   - 코어를 활용하는데 필요한 작업 양을 늘리지 않는 간단한 솔루션이 필요

## The Move Away from Threads

### 스레드의 한계
- 확장 가능한 방식으로 여러 작업을 실행하는 문제를 해결하지 못함
- 즉, 개발자가 직접 확장 가능한 솔루션을 만들어야함 (몇개의 스레드를 만들어야 하는지, 변화 상황에 따라 해당 숫자를 조정해야하는 등)
- 스레드를 생성하고 유지하는데 드는 비용이 애플리케이션에 부과됨

### 비동기 디자인 접근 방식

- 오랜 시간이 걸리는 작접을 시작할때 자주 사용
- 호출되면 비동기 함수는 백그라운드 스레드를 얻고 해당 스레드에서 원하는 작접을 시작한 다음, 작업이 실제로 완료되기 전에 반환. 
=> 일반적으로 이 작업은 백그라운드 스레드를 얻는 것, 해당 스레드에서 원하는 작접을 시작하는 것, 작업이 완료될때 호출자에게 알림을 보내는 것을 포함

#### Grand Central Dispatch (GCD)

- **GCD의 역할**: 
애플리케이션에서 작성하는 스레드 관리 코드를 시스템 수준으로 이동시킴
실행하려는 작업을 정의하고 적절한 디스패치 큐를 추가하기만 하면 됨!
GCD는 필요한 스레드를 생성하고, 작업을 그 스레드에서 실행할 수 있도록해준다.
- **GCD의 장점**:
이렇게 되면, 스레드 관리가 이제 시스템의 일부이므로 GCD는 전체적인 작업 관리 및 실행에 대한 종합적은 접근 방식을 제공하여 효율적인 성능을 제공한다.

#### Operation queues 

- **Operation queue의 역할**
디스패치 큐와 매우 유사한 object-c 객체
실행하려는 작업을 정의하고 그것들을 오퍼레이션 큐에 추가하면 작업 스케줄링 및 실행을 처리한다.

- **Operation queue의 장점**
GCD와 마찬가지로, 모든 스레드 관리를 담당하여 작업이 시스템에서 빠르고 효율적으로 실행되도록 한다.

#### Dispatch queues

- **Dispatch queue의 역할**
사용자 지정 작업을 실행하기 위한 C 기반의 메커니즘
직렬 또는 동시적으로 작업을 실행하지만 항상 **먼저 추가된 작업부터 실행(큐에 추가된 순서대로 빼내어 실행)**
  - serial dispatch queue는 한번에 하나의 작업만 실행하며, 완료되기 전에 새 작업을 실행하지 않는다.
  - concurrent dispatch queue는 이미 시작된 작업이 끝나기를 기다리지 않고 가능한 많은 작업을 시작한다.

- **Dispatch queue의 장점**
   - 직관적이고 간단한 프로그래밍 인터페이스를 제공
   - 자동 및 통합 스레드 풀 관리 제공
   - 조정된 어셈블리 속도를 제공
   - 더 많은 메모리 효율성을 제공 (스레드 스택이 응용 프로그램 메모리에 남아있지 않기 때문)
   - 부하가 많은 경우에도 커널에 묶이지 않음
   - 디스패치 큐로 작업을 비동기적 디스패치하면 큐가 **데드락**에 빠지지 않음
      - **데드락**은 일반적으로 두 개 이상의 스레드 또는 프로세스가 서로가 각자 가지고 있는 자원을 점유하고 기다리며 서로에게 할당된 자원을 반환하지 않는 상태를 의미한다. 즉, 프로그램이 멈춘다.
      - 디스패치 큐는 순차적으로 진행하기 때문에 데드락을 예방할 수 있다.
      - 또한, 시스템 레벨에서 스레드 관리를 처리하므로 효율적으로 작업을 처리할 수 있다.
   - concurrent 디스패치큐는 동시에 여러 작업을 처리함으로써 성능을 최적화하면서도 안정적인 동작을 보장한다. (They scale gracefully under contention.)
   - 직렬 디스패치 큐는 락 및 다른 동기화 기본 요소에 대한 효율적인 대안을 제공한다.

- **Dispatch queue 활용방법**

디스패치 큐로 보내는 task는 함수나 블록객체로 캡슐화해야한다.
블록 객체는 개념적으로 함수 포인터와 유사하지만 몇가지 추가적인 이점이있다.
  - 블록은 자체 lexical scope에서 정의하는 대신 일반적으로 다른 함수나 메소드 내에서 정의하여 해당 함수나 메소드에서 다른 변수에 접근할 수 있도록 한다.
     - lexical scope란, 변수가 코드에서 어디에서 사용가능한지 나타내는 개념
  - 원래 scope에서 이동하여 힙으로 복사될 수 있음 (디스패치 큐에 제출될 때)
  - 이런 특성 덕분에 적은 양의 코드로 매우 동적인 작업을 구현할 수 있음!

#### Dispatch source

- **Dispatch source의 역할**
특정 유형의 시스템 이벤트를 비동기적으로 처리하기 위한 C 기반 메커니즘
특정 유형의 시스템 이벤트에 대한 정보를 캡슐화하고, 해당 이벤트가 발생할때 마다 특정 블록객체 또는 함수를 디스패치 큐에 제출한다.

- **Dispatch source를 사용할 수 있는 유형(시스템 이벤트 모니터링)**
   - Timer : 5분마다 앱을 업데이트하려면 타이머를 설정하여 업데이트 할 수 있음
   - Signal handler : 운영체제로부터 발생하는 시그널 처리, 프로세스에 중요한 정보 전달 및 프로세스 종료
   - Descriptor-related 이벤트 : file descriptor, 파일이나 소켓에 새로운 데이터가 도착했을 때 해당 파일 디스크립터에 대한 이벤트 생성, 데이터 처리
   - Process-related 이벤트 : 앱에서 특정 프로세스의 상태 변경에 대한 알림을 받고자 한다면 프로세스를 모니터링 할 수 있다.(프로세스의 생성, 상태, 종료등 이벤트를 처리)
   - Mach port 이벤트: Mach port는 macOS, iOS 운영체제에서 프로세스 간 통신에 사용되며 Mach port의 상태 변경 및 데이터 전송등을 처리한다.
   - 사용자가 트리거하는 사용자 정의 이벤트 : 앱에서 직접 생성한 이벤트를 처리
  
#### Operation Queues

- **Operation Queue의 역할**
Cocoa에서 concurrent 디스패치 큐에 상응하는 개념, NSOperationQueue 클래스로 구현
   - 오퍼레이션 큐에 제출하는 task는 NSOperation 클래스의 인스턴스여야 한다.
   - 오퍼레이션 객체는 수행할 작업과 수행에 필요한 모든 데이터를 캡슐화하는 object-c 객체
   - NSOperation 클래스는 추상 클래스, 사용자 지정 하위 클래스를 정의하여 작업을 수행 (Foundation 프레임워크에 몇가지 구체적은 하위클래스가 포함되어 있음)
   
  디스패치 큐는 선입선출 숭서대로 작업하지만, 오퍼레이션 큐는 **다른 요소들을 고려하여 작업의 실행 순서를 결정한다.**
   - 가장 중요한 요소는, 특정 작업이 다른 작업의 완료에 종속되는지 여부이다.
   - 의존성을 구성하고 이를 사용하여 복잡한 실행 순서 그래프를 만들 수 있음.

  오퍼레이션 객체는 KVO 알림을 생성하여 작업 진행상황을 모니터링.
오퍼레이션 큐는 항상 작업을 동시에 실행하지만, 필요한 경우 의존성을 사용하여 직렬적으로 실행 될 수 있도록 할 수 있음!


## Asynchronous Design Techniques (비동기적 설계 기술)

- **동시성이 필요한지 우선적으로 고려해보기**
동시성은 주 스레드가 사용자 이벤트에 응답할 수 있도록 보장하여 코드의 응답성을 향상시킬 수 있고, 동일한 시간에 더 많은 작업을 수행하여 코드의 효율성을 높일수도 있으나 **오버헤드가 증가하고 코드의 복잡성도 증가하여 디버깅이 어려워질 수 있다.**
- **복잡성으로 인해 제품 수명 주기의 끝에서 그냥 추가할 수 있는 기능이 아니다**
애플리케이션이 수행하는 작업과 해당 작업을 수행하는데 사용되는 데이터 구조를 신중하게 고려해야한다. 그러므로 설계주기의 **시작**부터 **몇가지의 목표**를 설정하고 **접근방식**에 대해 고민해봐야한다.

### STEP1. 애플리케이션의 예상동작 정의하기

- **올바른 예상 동작 정의**
설계를 검증할 수 있는 방법, 동시성 도입으로 얻을 수 있는 예상 성능 향상에 대한 아이디어 제공 가능

- **애플리케이션이 수행하는 작업과 각 작업에 연관된 개체 또는 데이터 구조를 나열하기**
초기에는 사용자가 메뉴 항목을 선택하거나 버튼을 클릭할 때 수행되는 작업부터 시작 (구체적인동작, 시작과 끝이 있는 예상동작)
사용자 상호작용 없이 수행하는 Timer 기반과 같은 다른 유형의 작업도 열거!

- **수행하는 일련의 단계로 더 자세히 분해하기**
이 단계에서는 데이터 구조와 객체를 수정해야하는 방법과 해당 수정이 애플리케이션의 전체 상태에 어떤 영향을 미치는지 고려해야한다.
객체와 데이터 구조사이의 의존성도 기록해야한다.
   - 동일한 변경 내용을 만드는 경우, 한 객체의 변경 사항이 다른 객체에 영향을 미치는지 기록하는 것이 중요
   - 객체가 독립적으로 수정될 수 있는 경우, 그곳에서 수정을 병렬로 수행할 수 있는지 여부를 고려

### STEP2. 실행 가능한 작업 단위를 분해

- **코드에서 동시성을 활용할 수 있는 장소를 파악하기**
하나 이상의 단계의 순서를 변경하면 결과가 달라지는 경우, 해당 단계를 계속 직렬로 수행해야한다.
그러나, 순서를 변경해도 결과에 영향을 미치지 않는 경우, 해당 단계를 동시에 수행하는 것을 고려해야한다.
두가지 모두 **수행할 작업 단위를 정의하고, 블록 또는 작업 객체를 사용하여 해당 작업 단위를 캡슐화하고 적절한 큐에 디스패치한다.**

- **실행 가능한 작업 단위에 대해서는 처음엔 수행되는 작업 양에 대해걱정하지 않기**
디스패치 큐 및 오퍼레이션 큐의 장점 중 하나는 기존 스레드이 비해 비용이 훨씬 적어 더 작은 작업 단위를 효율적으로 실행할 수 있다는 것이다.

### STEP3. 필요한 큐 확인

STEP2 에서 독립적인 실행 단위인 블록 객체나 작업 객체로 캡슐화되었으므로 해당 코드를 실행할 큐를 정의해야한다.

- **실행해야 하는 순서 검토**
   - **블록객체인 경우**
   직렬디스패치 또는 병렬디스패치 큐에 추가할 수 있다.
   특정 순서가 필요한 경우, 직렬 디스패치 큐에 추가
   특성 순서가 필요하지 않은 경우, 병렬 디스패치 큐에 추가하거나 여러개의 디스패치 큐에 추가할 수 있다.
   - **작업객체 (Task)인 경우**
   큐의 선택보다는 객체의 구성이 더 중요하다.
   작업 객체를 직렬로 수행하려면 **객체간에 의존성**을 구성해야한다.
   의존성은 해당 작업이 필요로 하는 객체가 작업을 완료할 때 까지 다른 작업이 실행되지 않도록 한다.
   
   
### 효율성 향상을 위한 팁

- **메모리 사용이 중요한 경우**
작업 내에서 직접 값을 계산하는 것이 적절
애플리케이션이 이미 메모리 한계에 달해있는 경우, 메인 메모리에서 캐시된 값을 로딩하는 것 보다 직접 값을 계산하는 것이  더 빠를 수 있다.
**직접 계산은 해당 프로세서 코어의 레지스터와 캐시를 사용하기 때문에 메인 메모리보다 훨씬 빠르다. 성능 향상의 이점에서만 시도해야한다.**

- **serial task을 빠르게 식별하고 병렬적으로 처리하기**
작업이 일부 공유 리소스에 의존하여 반드시 serial 로 실행되어야 하는 경우, 그 공유 리소스를 제거하도록 아키텍처를 변경하기
각 클라이언트가 필요한 리소스의 사본을 만들거나 리소스 자체를 제거하는 방법을 고려해볼 수 있다.

- **Lock 사용 피하기**
디스패치 큐, 오퍼레이션 큐를 활용하여 대부분의 상황에서는 락이 필요하지 않다.
공유 리소스를 보호하기 위해 락을 사용하는 대신, task를 올바른 순서로 실행할 수 있도록 직렬큐 또는 작업 객체 의존성을 지정할 수 있다.

- **시스템 프레임 워크 활용하기**
동시성을 달성하는 가장 좋은 방법은 시스템 프레임워크가 제공하는 내장된 동시성을 활용하는 것이다.
많은 프레임워크가 내부적으로 스레드 및 기타 기술을 사용하여 병렬적인 동작을 구현한다.
작업을 정의할 때, **이미 존재하는 프레임워크에서 함수나 메서드가 있는지 찾아보기**

## Performance Implications (성능영향)

- **동시성이 애플리케이션의 효율성과 반응성을 보장하는 것은 아니다**
오퍼레이션 큐, 디스패치 큐, 디스패치 소스는 더 많은 코드를 동시에 실행하기 쉽게 해주지만 애플리케이션의 효율성 또는 반응성을 보장하는 것은 아니다.
- **set of baseline metrics를 수집하여 효율성 개선 유무를 비교하여 확인해야 한다.**
큐 또는 스레드를 사용하여 코드에 어떤 정도의 동시성을 도입하기 전에는 항상 애플리케이션의 현재 성능을 반영하는 일련의 set of baseline metrics를 수집해야한다. 변경사항을 도입한 후에는 추가적은 metrics를 수집하여 기준과 비교해서 애플리케이션의 효율성이 개선되었는지 확인해야한다.

## Concurrency and Other Technologies (동시성과 다른 기술)

코드를 모듈화된 작업으로 나누는 것은 동시성을 개선하는데 가장 좋은 방법이지만, 모든 요구를 충족시키지 못한다. 

### OpenCL and Concurrency

- **Open Computing Language(OpenCL)의 역할**
컴퓨터의 그래픽 프로세서에서 일반 목적의 계산을 수행하기 위한 표준 기술
대향의 데이터 집합에 대해 적용할 well-defined 계산 집합이 있는 경우 사용하는 것이 좋음
   - 예를 들어, 이미지의 픽셀에 대한 필터 계산을 수행
   - 여러 값을 동시에 계산하는 복잡한 수행
   - 병렬적으로 데이터가 처리될 수 있는 문제 집합에 적합

 일반적인 목적의 계산에는 적합하지 않다. 왜냐하면, 그래픽 카드에서 데이터 및 필요한 작업 커널을 준비하고 전송하는데 노력이 필요하고 OpenCL에서 생성된 결과를 검색하는데도 노력이 든다.
 
 **시스템과 상호작용하는 작업은 일반적으로 OpenCL과 함께 사용하는 것이 권장되지 않음**

### 스레드를 사용하는 경우
애플리케이션에 따라 오퍼레이션 큐와 디스패치 큐 말고 다른 방식으로 구현해야하는 특정 작업의 경우 스레드를 직접 만들어서 사용해야 한다.
직접 만드는 경우, 가능한 적은 스레드를 만들고 다른 방법으로 해야하는 경우에만 사용해야 한다.
스레드는 실시간으로 실행되어야 하는 코드를 구현하기에 좋고, 디스패치 큐는 작업을 빠르게 수행하지만 실시간 제약 조건을 충족시키지 않는다. 따라서 **백그라운드에서 실행되는 코드에 대해 더 예측 가능한 동작이 필요한 경우 스레드가 더 좋을 수 있다.**

----
## 참고
[동시성 공식문서 ](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW1)



## 병렬 vs 동시성 
- 병렬 (다중 코어) 
- 동시성 (다중 스레드) : 하나의 코어가 여러가지 일을 동시에 하는 것, 코어가 여러개여도 동시성 프로그래밍이 일어날 수 있다.
- 둘이 상반되는 개념이 아니다.
- 카톡에서 동영상 다운로드 => 메세지도 보내고, 사진도 보고 이러려면 동시성 프로그래밍이 필요

## 동기 vs 비동기
- 동기 : 앞의 작업이 끝날 때 까지 기다림
- 비동기 : 앞의 작업이 끝나기를 기다리지 않고 다음 작업이 진행됨
- 동시성 프로그램은 동기, 비동기가 둘다 사용될 수 있다. 스레드별로 달라진다. 동영상 다운받으면서 안기다리고 싶으면 => 비동기로, 비동기의 스레드에서 끝난다음 새로운 동영상을 보고 싶으면 => 동기로
