# CPU의 작동원리

# 학습내용
- ALU
- 제어장치
- 레지스터
- 명령어 사이클
- 인터럽트

----
# ALU
ALU를 살펴보기 전, CPU에 대한 개념을 다시 잡아보자.
```
CPU란 메모리에 저장된 명령어를 읽고, 해석하고, 실행하는 장치이다.
```
그렇다면, ALU는 무엇일까?

```
ALU는 계산하는 장치이다.
```

## ALU가 계산하는 과정

1. `레지스터`로부터 `피연산자`를 전달받는다.
   - 피연산자는 숫자와 같은 연산할 정보를 의미 
2. `제어장치`로부터 `연산`을 전달받는다.
   - 연산자는 부호를 의미
3. 계산을 완료하여 `레지스터`에 `결과값`을 전달한다.
4. 연산결과에 대한 `부가정보`를 `플래그 레지스터`에 전달한다.

이때 `3`번 과정을 보면 결과값을 레지스터에 저장하게 되는데, 그 이유가 무엇일까? 왜 메모리에 바로 저장하는 것이 아니라 임시저장공간인 레지스터에 저장할까? 🧐
- 왜나하면, CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 훨씬 빠르기 때문!


## 플래그 종류
- `부호 플래그` : 1이면 음수, 0이면 양수
- `제로 플래그` : 1이면 결과가 0, 0이면 결과가 0이 아님
- `캐리 플래그` : 1이면 올림수나 빌림수가 발생, 0이면 발생하지 않았음
- `오버플로우 플래그` : 1이면 오버플로우 발생, 0이면 발생하지 않았음
- `인터럽트 플래그` : 1이면 인터럽트 가능, 0이면 불가능
- `슈퍼바이저 플래그` : 1이면 커널모드로 실행 중, 0이면 사용자 모드로 실행 중 

문제) ALU를 통해 계산된 결과값이 101(2) 이고, 부호 플래그의 값이 1이라면 이 결과의 십진수는 무엇일까?

풀이) 부호 플래그가 1이라면 이 수는 음수임을 의미하고 101을 음수로 바꾸면 010 에 +1 을 해서 011 이다.
따라서 011을 십진수로 바꾸면 3이 되고 음수이기 때문에 정답은 `-3`이 된다.

----

# 제어장치
```
제어장치란, 제어신호를 발생시키고 해석하는 장치이다.
```

그렇다면, 어떤 것을 받아들이고 어떤 것을 내보낼까? 🧐

1. 클럭 신호를 받아들인다.

```
클럭 신호란, 컴퓨터의 모든 부품이 박자에 맞춰 일사불란하게 움직일 수 있게 하는 시간 단위를 뜻한다.
```

클럭의 주기에 맞춰서 컴퓨터의 부품들이 일을 하게 된다. 이때 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있다.

2. 해석해야할 명령어를 받아들인다.

`명령어 레지스터`라는 레지스터에 명령어가 저장되는데 이 명령어 레지스터로 부터 해석할 명령어를 받아들인다.

3. 플래그 레지스터 속 플래그 값을 받아들인다.

결과값의 부가정보인 플래그 값을 받아들여 제어신호를 발생시킨다.

4. 시스템 버스 중 제어버스로 전달된 제어신호를 받아들인다.

CPU 뿐만아니라 입출력장치를 비롯한 외부 장치로 부터 신호를 전달한다. 즉 제어버스롤 제어 신호를 내보내고 받아들인다.

----

# 레지스터

```
레지스터란, CPU안에 있는 임시 보관 장치이다.
``` 

## 레지스터의 종류
- `프로그램 카운터` : 메모리에서 읽어 들일 명령어의 주소를 저장
- `메모리 주소 레지스터` : 프로그램 카운터에서 읽어들일 명령어의 주소가 저장된다. 
   - 예를 들어, 프로그램 카운터가 메모리 `1000번지`에 있는 명령어를 읽어들일려고 받아왔으면, 메모리 주소 레지스터에 `1000번지`가 입력된다.
   - `제어장치`의 메모리 읽기 제어신호 (제어버스) + `메모리 주소 레지스터`에 저장된 주소(주소버스) => 메모리 접근

- `메모리 버퍼 레지스터` : 데이터와 명령어를 저장하는 레지스터
    - 메모리 1000번지에 있는 데이터가 데이터 버스를 통해 메모리 버퍼 레지스터에 전달된다.
    - 이때, 프로그램 카운터는 1이 증가하여 다음 명령어를 읽을 준비를 한다.
- `명령어 레지스터` : 메모리 버퍼 레지스터에 저장된 값이 명령어 레지스터로 이동. 해석할 명령어가 저장된다.


이러한 과정이 순차적으로 진행된다. 프로그램 카운터가 1씩 증가하면서 메모리 속 프로그램을 읽어들이고 해석한다.

## 레지스터의 종류 2 

- `범용 레지스터` : 데이터와 주소를 모두 저장할 수 있다.
- `플래그 레지스터` : 연산 결과의 부가적인 정보를 저장한다.

## 주소 지정 방식
- `스택 주소 지정 방식` : 스택 포인터라는, 스택의 꼭대기를 가리키는 레지스터를 이용한 주소 지정 방식이다.
- `변위 주소 지정 방식` : 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효주소를 얻어내는 주소 지정 방식
   - `상대 주소 지정 방식` : 오퍼랜드 + 프로그램 카운터 => 유효주소
   - `베이스 레지스터 주소 지정 방식` : 오퍼랜드 + 베이스레지스터 (기준주소) => 유효주소

---

# 명령어 사이클
```
명령어 사이클이란, 간단하게 말해서 명령어를 처리하는 흐름을 의미한다.
```

큰 틀에서 인출과 실행 사이클이 존재한다.
`인출 사이클`은 메모리에서 CPU로 명령어를 가져오는 것을 말하고, `실행 사이클`은 가져온 명령어를 실행하는 것을 말한다.
이때, 메모리에 주소가 올라가 있으면 그 주소를 한번 더 접근하는 과정이 필요한데 이를 `간접 사이클`이라고 한다.

## 인터럽트

```
인터럽트란, CPU가 수행 중인 작업을 중단하는 신호를 의미한다.
```

### 동기 인터럽트 
CPU에 의해 발생하는 인터럽트.
CPU가 작업을 수행하다가 예기치 못한 상황을 마주했을 때 발생하는 인터럽트

### 비동기 인터럽트
주로 입출력 장치에 의한 알람과 같다.
입출력 작업 도중에 효율적으로 명령어를 처리하기 위헤 알림과 같은 하드웨어 인터럽트를 사용한다.

#### 처리 순서
1. 입출력 장치가 CPU에게 인터럽트 요청 신호를 보낸다.
    - 지금 잠시 중단해도돼?
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부를 확인한다.
3. 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 인터럽트를 받아들일 수 있는지 확인한다.
4. CPU가 현재 수행중인 작업은 메모리의 스택영역에 백업한다.
5. `인터럽트 벡터`를 활용하여 `인터럽트 서비스 루틴` 프로그램을 실행한다.
   - 인터럽트 벡터 : 인터럽스 서비스 루틴을 식별하기 위한 정보
   - 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위한 프로그램
   - 인터럽트 서비스 루틴은 고유한 인터럽트 벡터가 존재하고, 인터럽트 벡터를 통해서 서비스의 첫 시작점을 확인한다.
6. 서비스 루틴이 끝나면 백업된 작업을 복구해서 실행한다.


