# 14. 가상 메모리

## 학습내용
- 스와핑
- 메모리 할당 (최초, 최적, 최악 적합)
- 외부 단편화
- 페이징 기법 : 가상 메모리 관리
   - 페이지 테이블
   - PTBR
   - TLB
- 페이징 주소 변환 
- 페이지 테이블 엔트리 
   - 유효비트
   - 보호비트
   - 참조비트
   - 수정비트 
- 요구페이징
- 페이지 교체 알고리즘
- 스래싱
- 프레임 할당

## 스와핑
```
실행할 프로세스는 메모리에 적재하는 스왑인
실행하지 않는 프로세스는 보조기억장치의 스왑영역에 넣는 스왑아웃
이러한 과정을 스와핑이라고 한다.

일종의 메모리 관리 기법이다.
```

스와핑을 사용하면 실제 메모리 크기가 큰 프로세스들도 실행할 수 있는 장점이 있다.

## 메모리 할당
- 최초 적합 : 운영 체제가 메모리의 빈 공간을 검색하다가 순차례대로 프로세스를 적재하는 방식
- 최적 적합 : 운영 체제가 메모리의 빈 공간을 검색하다가 그 중 가장 작은 공간에 프로세스를 적재하는 방식
- 최악 적합 : 운영 체제가 메모리의 빈 공간을 검색하다가 그 중 가장 큰 공간에 프로세스를 적재하는 방식

## 외부 단편화
여러 방식으로 메모리 공간에 프로세스를 적재할 때, 일부 공간들이 생기게 되는데 그러한 것을 외부 단편화라고 한다. 

즉 각각 공간이 30, 20인 메모리 빈 공간이 있는데 크기가 50인 프로세스가 그 공간에 적재될 수 없고 이러한 공간을 `외부 단편화` 발생이라고 한다.

이를 해결하기 위해 `압축` 하는 방법이 있는데, 공간을 재배치하고 빈 공간을 하나로 모으는 과정에서 `오버헤드` 발생 위험과 `프로세스 진행에 어려움`이 있다는 단점이 있다.

---

## 페이징

페이징은 가상 메모리를 관리하는 기법 중 하나인데, 가상 메모리가 무엇인지 먼저 알아보자!!

```
가상 메모리란, 실행하고자 하는 프로그램 일부만 메모리에 적재하여 실제 물리 메모리보다 큰 프로세스를 실행할 수 있게 하는 기술이다.
```

이제 페이징에 대해 알아보자!

```
페이징이란, 프로세스의 논리주소는 페이지 단위로 쪼개고 메모리 물리주소는 프레임 단위로 쪼개어 가상 메모리를 관리하는 기법이다.
```

이때, 페이지와 프레임 크기는 동일하다.
페이지 단위로 스와핑도 가능하다 (원리 동일)
필요한 일부 페이지만 메모리에 적재하고, 실행하지 않은 페이지들은 보조기억장치에 남겨둠

### 페이지 테이블 
실제 페이지가 메모리에 불연속적으로 적재되어 있으면 CPU가 확인하기 어려우니 프로세스마다 있는 페이지 테이블을 활용하여 프로세스의 페이지가 어디에 적재되어 있는지 확인할 수 있다.

```
요약하면, 프로세스는 각각 페이지 테이블을 가지고 있고, 페이지 테이블은 메모리에 적재되어 있다.
```

=> 그러나 이때는 내부 단편화 문제가 발생한다 
프로세스의 크기가 페이지로 딱 나눠떨어지지 않는 경우도 있으니깐

### PTBR (페이지 테이블 베이스 레지스터)
그럼 메모리에 적재되어 있는 페이지 테이블이 어디에 있는지 CPU가 어떻게 알 수 있을까?
바로 `PTBR`을 이용해서 확인할 수 있다.

### TLB
그럼 매번 CPU가 메모리에 접근해야하는데? 
이런 불필요한 접근을 막기 위해 캐시메모리인 TLB에 적재한다

CPU가 발생한 논리주소에 대한 페이지 번호가 TLB에 있는 경우 `TLB 히트` 라고 하고, 번호가 없는 경우 `TLB 미스`라고 한다.

히트 - 접근 1번
미스 - 접근 2번

## 주소 변환
하나의 페이지 / 프레임은 여러 주소를 포괄하고 있기 때문에, 특정 주소에 접근하려면 두 가지 정보가 필요하다.
- 어떤 페이지 / 프레임에 접근하고 싶은지
- 접근하려는 주소가 얼마나 떨어져 있는지

논리주소는 기본적으로 <페이지 번호, 변위>로 이루어져 있다.
이러한 논리주소는 페이지 테이블을 통해 물리주소 <프레임번호, 변위>로 변환된다.
페이지 크기랑 프레임 크기가 서로 같기 때문에 변위가 동일하여 찾기 수월하다.

## 페이지 테이블 엔트리
- 유효비트 : 현재 페이지가 메모리에 적재되어 있는지 아니면 스왑영역에 있는지 확인
- 보호비트 : 페이지 보호 기능, 페이지가 읽기 전용인지 읽기 쓰기 전용인지 확인
- 참조비트 : CPU가 이 페이지에 접근한적 있는지 확인
- 수정비트 : 이 페이지가 수정된 적이 있는지, 만약 읽기 쓰기 전용이어서 수정된 적 있다면 보조기억장치의 내용도 수정해야하기 때문에 필요. 비트값이 1이면 수정해야함 

### 쓰기 시 복사
fork()를 하면 부모와 동일한 프로세스가 자식 프로세스로 복사가 되는데, 이때 페이지 테이블이 똑같이 복사가 되지만 실제 접근하는 메모리 주소는 부모와 자식이 동일하게 접근한다.
만약 자식의 페이지에 수정이 발생하면 그 때 메모리에 페이지 복사본이 생성된다.

이를 쓰기 시 복사라고 하고 메모리 공간을 절약하는 방법이다.

### 계층적 페이징
페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식
너무 많은 계층이 생기면 오버헤드 발생 위험이 있다.

---

## 요구 페이징
요구되는 페이지만 적재하는 기법
- CPU가 특정페이지에 접근하는 명령을 내림
- 페이지가 메모리에 있는 경우 (유효비트1) CPU는 페이지가 적재된 프레임에 접근
- 메모리에 없다면(유효비트0) 페이지 폴트 발생
- 페이지를 메모리에 적재하고 다시 1번 과정부터 진행

## 페이지 교체 알고리즘
`페이지 폴트 횟수`가 적을 수록 좋은 방법이다.
- FIFO 페이지 교체 알고리즘 : 가장 오래된 애를 내보냄
- 2차기회 페이지 교체 알고리즘 : 가장 오래된 애를 내보내지만 참조비트가 1이면 한번더 기회를 줌 
- 최적 페이지 교체 알고리즘 : 빈도수가 가장 낮을, 가장 사용되지 않을 애를 내보냄 / 이 방법은 예측해야하기 때문에 실제로 구현하기 어렵다.
- LRU 페이지 교체 알고리즘 : 최적 페이지 교체 알고리즘이 예측이라면 이 방법은 이미 일어난, 즉 실제로 빈도수가 가장 낮은 페이지를 내보냄

## 스래싱과 프레임 할당
```
프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 스래싱이라고 한다.
```

늘 성능에 비례해서 증가하는 것은 아니다!
이러한 원인은 필요한 최소 프레임 수가 보장되어 있지 않기 때문이다.

- 균등할당 : 300개 프레임을 3개의 프로세스에 동일하게 100개씩 분배하는 방식
- 비례할당 : 프로세스 크기에 따라 할당 
- 작업집합 : 작업 집합의 크기만큼 프레임을 할당
- 페이지 폴트 빈도를 활용한 방식 : 상한선과 하한선을 따져가며 적당한 프레임 수를 확인

아래 두가지 방식 작업집합과 페이지 폴트 빈도를 활용한 방식은 프로세스 실행과정을 지켜봐야하므로 동적할당방식이다.
